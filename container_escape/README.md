# Baby's First Container Escape

A few years ago, I was a bright eyed college graduate, excited for my first
software development job. I had spent the last four years building
websites, making sweet data visualizations, and dabbling in machine learning.
On my first day I asked my manager, "So what does our team do?" The answer?
"Firmware security." Oh... I don't even know enough to ask any questions.

Fast forward, and I've been writing systems security code ever since,
and loving it! But recently, I've been getting a nagging feeling that
despite all this security experience, I've never actually pulled off
many of the exploits I'm defending against. So I've come to change that.
Today we are going to try to break out of a Linux container and get root
access on the host.

## Poking around the container

Let's start by creating a container and poking around a little bit. What exactly
am I escaping?

### Creating an LXD container

LXD is much simpler than docker so we'll use that. To set up an unprivileged
container to play around in do the following:

```
sudo apt update
sudo apt install lxc lxd
sudo useradd -m lxcuser
sudo usermod -a -G lxd lxcuser
sudo su - lxcuser

mkdir ~/.config/lxc
touch ~/.config/lxc/default.conf

# Edit the default.conf file to have below contents

sudo lxd init
lxc launch ubuntu:16.04 test
lxc start test
lxc exec test -- /bin/bash
```

### Poking Around

Lets run a few commands in the container do see what we're dealing with:

```
$ ps aux # Only a small number of processes
$ ls -l /proc/self/ns # Namespaces + cgroup are different than on the host
$ echo 1 > /proc/sysrq-trigger # Read-only filesystem
```

## Finding an exploitable bug

Alright, so how can I get out? I know that containers on Linux are basically
just a collection of kernel features used to isolate a process from the rest of
the system. The simplest way to bypass these isolation techniques in my mind is
to find a kernel vulnerability that will allow us to execute arbitrary code in
the kernel context. If I can do that, then I can probably just change my process'
namespaces, cgroup, etc to match the host. So what are my options?

**I could scour the kernel code to find some buffer overflow! Maybe a little
too ambitious for the first go 'round...**

**I could compile a kernel with a bunch of security features turned off?
That's not very fun.**

**Well... I could find a vulnerability that has already been fixed in newer kernels
but is still present in old kernels. Ya, that'll do. To the Google machine!**

CVE-2017-7308 is a priveledge escalation bug in the Linux kernel reported by Project Zero.
The full write-up can be found [here](
https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html).
As described in the blog post, a PoC for this exploit can be found [on github](
https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308).
This bug is explotable for all kernels from v3.2-rc1 to v4.11-rc5.

I want to pause here and say a big thanks to Andrey Konovalov for finding this bug!
Without him my little journey may have ended before it began.

While I do recommend reading the blog post, it can be a bit dense on first read.
Don't feel bad if you just want to try out the exploit and then go back and
try to understand how it works. I promise not to call you a script kiddie!

## Trying out the exploit

If I execute the PoC as-is from inside an unprivileged container, all I will
get is root access inside the container. All the kernel features I mentioned
before will still isolate me from the rest of the host. And the way we set up
the container, we already have root inside! I hear you, but let's just try it
out anyway and come back to those concerns later.

### Setting up an environment

Alright, we need to set up a machine and install a vulnerable kernel on it.
Your Linux machine has likely had this vulnerability fixed for a long time,
so let's make a KVM VM. I have installed Ubuntu 16.04.2 running kernel
4.8.0-41-generic.

Once the VM is set up, go ahead and make a new unprivileged container
in the same way we did before.

### Download the exploit

Andrey Konovalov's github has a PoC for the original privilege escalation
exploit [here](https://github.com/xairy/kernel-exploits/tree/master/CVE-2017-7308).

### Run the exploit

Building and running is dead simple. As long as you're running on the same kernel
described in the blog post, you can just do the following:

```
$ gcc -o poc poc.c
$ ./poc
```

The code can pretty easily be modified to run on different kernels, but the
function offsets in the payload need to be retrieved from /proc/kallsyms
on that kernel.

## Modifying the exploit for container escape

As-is the exploit elevates privileges from a normal user to root. Since we are
inside a container, elevating to root doesn't help us escape the container. But
don't worry, our payload executes in the kernel context, so we can modify the
payload to whatever we want. Remember, the original exploit finds the initial
kernel offset so we can bypass KASLR.

So what can we add the to payload to help us out? The following is roughly what
we can do (note that in the real payload, we call these functions by address).

```
// Copy task struct from init_nsproxy to pid 1 of the container
unsigned long long g = find_task_by_vpid(1);
switch_task_namespaces(( void *)g, (void *)init_nsproxy);

// Change the pid and mnt namespaces for pid 1 in the container
long fd = do_sys_open( AT_FDCWD, "/proc/1/ns/mnt", O_RDONLY, 0);
sys_setns(fd, 0);

fd = do_sys_open( AT_FDCWD, "/proc/1/ns/pid", O_RDONLY, 0);
sys_setns(fd, 0);
```

You can take a look at poc.c for the full exploit code. This is adapted from
Andrey's original PoC, with changes to the payload and offset defines for the
new functions we're using.

**Note, I got the function offsets from `/proc/kallsyms`. Any machine running
the same kernel can get you these offsets to be added to the kernel base address.
If you want to run the payload on a different kernel, you'll need to recompute all
the offsets.**

### Running the new payload

Alright, now is the moment of truth. Compile the code and run it. And... it
worked! Or at least the console output says it works. How can we be sure?

```
$ ps aux
```

We have a big list of process for all users!!

```
$ ls /home
```

Yep, looks like the host filesystem!

Alright, I have to admit, after I modified the payload, it didn't work on the
first try. I miscalculated some of the offsets and got some of the call patterns
wrong. But after a little tweaking, it worked like a charm.

Overall, I had a lot of fun trying out this exploit and learned a lot. Happy
hacking!
